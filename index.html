<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>Final Project Grafkom</title>
    <style>
        body {
            margin: 0;
            background: #bbbbbb;
            overflow: hidden;
        }
    </style>
	<script src="js/Math.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/threex.keyboardstate.js"></script>
    <script src="js/threex.planets.js"></script>
    <script src="js/ColladaLoader.js"></script>
    <script src="js/PointerLockControls.js"></script>
	<script src='js/threex.atmospherematerial.js'></script>
	<script src="js/threex.atmospheredatgui.js"></script>
    <script src="js/DeviceOrientationControls.js"></script>
	
	<!--<script src='vendor/three.js/build/three.min.js'></script>-->
	<!--<script src='vendor/three.js/examples/js/libs/dat.gui.min.js'></script>-->
</head>

<body>
    <script>
        var scene, camera, renderer, controls;
        var starSphere, spaceShip;
        var onRenderFcts= [];
        var lookAtx = 0, lookAty = 2, lookAtz = 3;
        var starTexture;
        var moon_count = 3;
        var moons = [];
        var moon_xmax = 7, moon_xmin = -7;
        var moon_ymax = 5, moon_ymin = -1;
        var moon_zstart = -50;
        var moon_speed = 40;
        
        init();
        render();
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
//            camera = new THREE.OrthographicCamera( 10 / - 2, 10 / 2, 10 / 2, 10 / - 2, 1, 1000 );
            camera.position.set(0, 2, 4);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            addGalaxy();
            loadShip();
            addLight();

            addMoon();

            setupControls();
            // addControls();
        }

        function addMoon() {
            for (var i = 0; i < moon_count; i++) {
                var moon = THREEx.Planets.createMoon();
                moons.push(moon);
                resetMoonPos(moon);
                scene.add(moon);
            }
        }

        function resetMoonPos(moon) {
            moon.position.z = -50;
            moon.position.x = (Math.random() * (moon_xmax - moon_xmin)) + moon_xmin;
            moon.position.y = (Math.random() * (moon_ymax - moon_ymin)) + moon_ymin;
        }

        function updateZMoon() {
            onRenderFcts.push(function(delta, now){
                    // console.log(i);
                for (var i = 0; i < moons.length; i++) {
                    moons[i].position.z += moon_speed * delta;

                    if (moons[i].position.z > 4) {
                        resetMoonPos(moons[i]);
                    }
                }
            });
        }

        function checkCollision() {
            onRenderFcts.push(function(delta, now){
                if( spaceShip === undefined || moons.length <= 0) return;

                for (var i = 0; i < moons.length; i++) {
                    var moonbox = new THREE.Box3().setFromObject(moons[i]);
                    var shipbox = new THREE.Box3().setFromObject(spaceShip);

                    if (moonbox.intersectsBox(shipbox)) {
                        console.log('nabrak');
                        resetMoonPos(moons[i]);
                    }                    
                }
            });
        }
        
        function addGalaxy() {
            starSphere  = createStarfield();
            scene.add(starSphere);
        }
        
         function createStarfield() {
            var texture = THREE.ImageUtils.loadTexture(THREEx.Planets.baseURL+'assets/galaxy_starfield.png');
            starTexture = texture;
            var material = new THREE.MeshBasicMaterial({
                map : texture,
                side : THREE.BackSide
            });
            var geometry = new THREE.SphereGeometry(100, 32, 32);
            var mesh = new THREE.Mesh(geometry, material);
            
            return mesh;
        }
        
        function addShip() {
            spaceShip.scale.set(.5, .5, .5);
            scene.add( spaceShip );
        }

        function loadShip() {
            var manager = new THREE.LoadingManager( addShip );
            var loader = new THREE.OBJLoader( manager );
            loader.load( 'assets/SmallSpaceFighter.obj', function ( obj ) {
                spaceShip = obj;
            }, function() { }, function() { } );
        }
        
        function addLight() {
            var hemiLight = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1.5 );
            scene.add(hemiLight);
            
//            hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
//            scene.add( hemiLightHelper );
        }
        
        function addControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.campingFactor = 0.25;
            controls.enableZoom = true;
        }
        
        function setupControls() {
            var keyboard  = new THREEx.KeyboardState();
			
            onRenderFcts.push(function(delta, now){
                if( spaceShip === null )  return;

                var speed = 10;
                if ( keyboard.pressed('a') ){
					if (spaceShip.position.x > -5)
                    spaceShip.position.x  -= speed * delta;
                } else if( keyboard.pressed('d') ){
					if (spaceShip.position.x < 5)
                    spaceShip.position.x  += speed * delta;
                } else if( keyboard.pressed('w') ) {
                    if (spaceShip.position.y < 4)
                        spaceShip.position.y += speed * delta;
                } else if( keyboard.pressed('s') ) {
                    if (spaceShip.position.y > -1)
                        spaceShip.position.y -= speed * delta;
                }
            })
        }
        
        function render() {
            updateZMoon();
            checkCollision();
            onRenderFcts.push(function(){
                renderer.render( scene, camera );		
            });
            
            var lastTimeMsec= null
            requestAnimationFrame(function animate(nowMsec){
                // keep looping
                requestAnimationFrame( animate );
                // measure time
                lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
                var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
                lastTimeMsec	= nowMsec
                // call each update function
                onRenderFcts.forEach(function(onRenderFct){
                    onRenderFct(deltaMsec/1000, nowMsec/1000)
                })
            });
        }
    </script>
</body>

</html>
